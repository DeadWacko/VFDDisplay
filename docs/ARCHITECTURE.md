# VFD Display Driver — Architecture

Этот документ описывает текущую и целевую архитектуру драйвера VFD-дисплея для RP2040.

## 1. Цели архитектуры

- **Переиспользуемость**: Сделать драйвер модулем, пригодным для всех будущих проектов.
- **Разделение ответственности**: Чёткое деление на низкоуровневый (LL) и высокоуровневый (HL) API.
- **Надёжность**: Эффекты и оверлеи не должны ломать основное содержимое (Content).
- **Поддержка**: Облегчение тестирования, сопровождения и добавления новых визуальных эффектов.

## 2. Уровни архитектуры

Проект делится на два основных слоя:

```plaintext
   High-Level API       (display_api.h / будущие *.c)
        ▲
        │
   Low-Level API        (display_ll.h / текущий display.c → refactor)
        ▲
        │
   Hardware (RP2040, GPIO, SPI, таймеры, ADC)
```

### 2.1. Low-Level API (display_ll)

**Назначение**: Прямой контроль над VFD-дисплеем. На этом уровне нет понятий времени, чисел, текста или сложных анимаций.

**Задачи LL-слоя**:
- Хранение буфера сегментов
- Управление яркостью по разрядам
- Мультиплексирование разрядов (fast refresh)
- Программный PWM для яркости
- (В будущем) Подключение PIO-бэкенда

**Типичные функции**:
```c
display_ll_init(digit_count);
display_ll_get_buffer();
display_ll_set_digit_raw(idx, segmask);
display_ll_set_brightness(idx, level);
display_ll_set_brightness_all(level);
display_ll_start_refresh();
display_ll_stop_refresh();
```

### 2.2. High-Level API (display_api)

**Назначение**: Удобный интерфейс для приложений (часы, индикаторы, IoT-проекты). HL-слой не работает с железом напрямую, опираясь только на LL-API.

**Задачи HL-слоя**:
- Форматирование времени и даты
- Отображение чисел и текста
- Управление режимами отображения
- Запуск эффектов (wave, pulse, fade, glitch, matrix)
- Оверлеи (индикация Boot, WiFi, NTP)
- Ночной режим и адаптивная яркость

**Примеры функций**:
```c
display_init(digit_count);
display_show_time(h, m, show_colon);
display_show_number(value);
display_show_text("Err1");
display_fx_wave(duration_ms);
display_overlay_ntp(duration_ms);
display_set_brightness(level);
```

## 3. Текущее состояние (Legacy)

На данный момент (версия 0.1.x):

- Основная логика реализована в одном файле: `src/display.c`
- Заголовок `include/display.h` смешивает LL и HL функции
- Эффекты и оверлеи реализованы внутри `display.c`

Для перехода созданы новые заголовки-контракты:
- `include/display_ll.h` — целевой низкоуровневый API
- `include/display_api.h` — целевой высокоуровневый API

## 4. Целевая структура исходников

План разбиения директории `src/`:

```plaintext
src/
├── display_ll.c       // Низкоуровневая реализация (буфер, яркость, refresh)
├── display_core.c     // Общие структуры и базовая логика
├── display_content.c  // Числа, текст, время, форматирование
├── display_fx.c       // Эффекты яркости (wave, pulse, fade, glitch)
├── display_overlay.c  // Оверлеи (boot, WiFi, NTP и т.п.)
└── logging.c          // Реализация логгера (опционально)
```

> Примечание: На первом этапе допускается оставлять часть логики в `display.c`, постепенно разнося её по модулям.

## 5. Режимы и состояния

Драйвер оперирует тремя основными режимами:

```c
typedef enum {
    DISPLAY_MODE_CONTENT = 0,  // Обычное содержимое (время, числа, текст)
    DISPLAY_MODE_EFFECT,       // Временный эффект, заменяющий картинку
    DISPLAY_MODE_OVERLAY       // Оверлей поверх содержимого (boot, WiFi, NTP)
} display_mode_t;
```

1. **CONTENT** — Базовый слой: то, что «по-настоящему» должно быть на дисплее (время, режим, измерение).
2. **EFFECT** — Временные анимации. Могут полностью перекрывать картинку, но не должны ломать данные в CONTENT.
3. **OVERLAY** — Служебные состояния (например, значок WiFi), показываемые поверх CONTENT или FX.

**Ключевой принцип**: Ни один эффект или оверлей не должен портить базовый буфер CONTENT. По завершении эффекта состояние дисплея восстанавливается.

## 6. Таймеры и обновление

Система использует несколько уровней таймеров:

- **Fast Refresh Timer**  
  Частота: 100–200 Гц  
  Отвечает за мультиплексирование разрядов и PWM яркости

- **Effect/Overlay Heartbeat**  
  Частота: ~60 FPS (≈16 мс)  
  Синхронизация всех визуальных эффектов

- **RTC / Update**  
  Частота: 1 Гц  
  Чтение часов и обновление CONTENT-буфера

- **Adaptive Brightness**  
  Периодический опрос ADC (фоторезистора) и пересчёт яркости

- **Dot / Colon Blinking**  
  Отдельный таймер для мигания разделителей в режиме часов

## 7. План рефакторинга

1. Сохранение стабильности: Обеспечить работу текущего примера `clock_stress_test`
2. Выделение LL-слоя:
   - Переместить функции буфера и яркости в `display_ll.c`
   - Оставить старые функции в `display.c` как thin-wrappers
3. Реализация HL-API: Начать наполнение `display_api.c`
4. Миграция эффектов: Перенос в `display_fx.c` с привязкой к heartbeat таймеру
5. Миграция оверлеев: Перенос в `display_overlay.c` с реализацией save/restore буфера
6. Обновление примеров: Перевод примеров на использование `display_api.h`
7. Документация: Обновление `API.md`, пометка старого `display.h` как deprecated

## 8. Совместимость

- В процессе рефакторинга исходный API (`display.h`) сохраняется для совместимости
- Новый API внедряется инкрементально
- После стабилизации старый заголовок будет объявлен устаревшим или останется простой обёрткой

