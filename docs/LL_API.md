
---

# Low-Level Layer v4.0 — API Reference

**Платформа:** RP2040 (Raspberry Pi Pico / Pico W)  
**Версия:** `v1.0.0`
**Статус:** `stable`

---

## 1. Обзор

Модуль **Low-Level (LL)** предоставляет прямой интерфейс к аппаратному обеспечению дисплея. Он абстрагирует работу с GPIO, таймерами и прерываниями, предоставляя «виртуальный кадровый буфер» с аппаратным мультиплексированием.

**Ключевые возможности:**
*   **Драйвер сдвиговых регистров:** Программная реализация SPI для каскада 74HC595.
*   **Фоновая развертка:** Использование `repeating_timer` (RP2040 SDK) для стабильной частоты обновления.
*   **Глубина яркости:** 8 бит (0..255) на каждый разряд (Per-digit PWM).
*   **Гамма-коррекция:** Встроенная LUT/функция для линеаризации восприятия яркости.
*   **Anti-Ghosting:** Аппаратная защита от паразитной засветки соседних разрядов.

---

## 2. Аппаратная конфигурация

Драйвер ожидает следующую схему подключения сдвиговых регистров (74HC595):
1.  **Порядок данных:** Сначала загружается маска сетки (Grid), затем маска сегментов (Segments).
2.  **Протокол:**
    *   `Clock` (SH_CP)
    *   `Data` (DS)
    *   `Latch` (ST_CP)

---

## 3. Конфигурация и Типы данных

### `display_ll_config_t`
Структура конфигурации инициализации.

```c
typedef struct {
    uint8_t data_pin;        // GPIO для Data (DS)
    uint8_t clock_pin;       // GPIO для Clock (SH_CP)
    uint8_t latch_pin;       // GPIO для Latch (ST_CP)
    
    uint8_t digit_count;     // Количество разрядов (1..10)
    uint16_t refresh_rate_hz;// Частота обновления всего дисплея (рек. 100-120 Гц)
} display_ll_config_t;
```

### `vfd_seg_t`
Тип данных для маски сегментов. Обычно `uint8_t`.
*   Бит 1 = Сегмент включен.
*   Бит 0 = Сегмент выключен.

---

## 4. Функции управления (API)

### Инициализация

#### `bool display_ll_init(const display_ll_config_t *cfg)`
Инициализирует GPIO, выделяет память под буферы и настраивает внутренние структуры.
*   **cfg:** Указатель на заполненную структуру конфигурации.
*   **Возврат:** `true` при успехе, `false` при ошибке (неверные пины, нет памяти).
*   *Примечание:* Не запускает развертку (см. `start_refresh`).

#### `void display_ll_deinit(void)`
Останавливает таймеры, освобождает ресурсы и переводит пины в состояние High-Z.

---

### Управление разверткой

#### `bool display_ll_start_refresh(void)`
Запускает прерывания таймера. Дисплей начинает светиться.
*   **Возврат:** `true`, если таймер успешно запущен.

#### `void display_ll_stop_refresh(void)`
Останавливает прерывания и гасит дисплей (отправляет 0x00).

---

### Рендеринг (Вывод данных)

Все функции потокобезопасны (используют `save_and_disable_interrupts`).

#### `void display_ll_set_digit_raw(uint8_t idx, vfd_seg_t seg)`
Устанавливает маску сегментов для конкретного разряда.
*   **idx:** Индекс разряда (0..digit_count-1).
*   **seg:** Битовая маска (шрифт).

#### `void display_ll_set_brightness(uint8_t idx, uint8_t level)`
Устанавливает яркость для конкретного разряда.
*   **idx:** Индекс разряда.
*   **level:** Уровень PWM (0 = выкл, 255 = макс).

#### `void display_ll_set_brightness_all(uint8_t level)`
Устанавливает одинаковую яркость для всех разрядов.
*   **level:** Уровень PWM (0..255).

---

### Утилиты и Гамма

#### `void display_ll_enable_gamma(bool enable)`
Включает или выключает автоматическое применение гаммы внутри драйвера.
*   *Default:* true.

#### `uint8_t display_ll_apply_gamma(uint8_t linear)`
Вспомогательная функция. Преобразует линейное значение яркости (0..255) в скорректированное по формуле $x^2/255$.

#### `vfd_seg_t *display_ll_get_buffer(void)`
Возвращает "сырой" указатель на видеопамять (массив сегментов).
*   *Внимание:* Использовать только для чтения или отладки. Прямая запись без блокировки прерываний может привести к артефактам.

---

## 5. Внутренняя логика работы (Architecture)

Драйвер работает на базе двух событий:

1.  **Slot Timer (Repeating Timer):**
    *   Срабатывает с частотой `RefreshRate * DigitCount`.
    *   Загружает данные для *следующего* разряда в сдвиговый регистр.
    *   Делает `LATCH`.
    *   Если яркость < 255, взводит однократный `Alarm` на выключение.

2.  **Clear Alarm (Hardware Alarm):**
    *   Срабатывает через время $T_{on}$, пропорциональное яркости.
    *   Гасит дисплей (отправляет 0x00), реализуя PWM.

### Anti-Ghosting (Защита от засветки)
В версии 4.0 реализован механизм "Dead Time".
Время горения рассчитывается так:
$$T_{on} = \min(PWM_{calc}, T_{slot} - 10\mu s)$$
Это гарантирует, что аноды погаснут за 10 микросекунд до переключения на следующую сетку, исключая паразитную засветку.

---

## 6. Пример использования 

Пример использования LL-драйвера без HL-библиотеки:

```c
#include "display_ll.h"

void main() {
    // 1. Настройка
    display_ll_config_t cfg = {
        .data_pin = 15,
        .clock_pin = 14,
        .latch_pin = 13,
        .digit_count = 4,
        .refresh_rate_hz = 120
    };

    // 2. Инициализация
    display_ll_init(&cfg);

    // 3. Заполнение буфера (Маска 0xFF - все сегменты)
    for(int i=0; i<4; i++) {
        display_ll_set_digit_raw(i, 0xFF); 
        display_ll_set_brightness(i, 50); // 20% яркости
    }

    // 4. Запуск развертки
    display_ll_start_refresh();

    while(1) {
        // Дисплей работает в прерываниях
        tight_loop_contents();
    }
}
```