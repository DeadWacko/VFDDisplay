# Low-Level Layer — API Reference

**Платформа:** RP2040 (Raspberry Pi Pico / Pico W)  
**Версия:** `v1.0.0`
**Статус:** `stable`

---

## 1. Обзор

Модуль **Low-Level (LL)** предоставляет прямой интерфейс к аппаратному обеспечению дисплея. Он абстрагирует работу с GPIO, таймерами и прерываниями, предоставляя «виртуальный кадровый буфер» с аппаратным мультиплексированием.

**Ключевые возможности:**
*   **Драйвер сдвиговых регистров:** Программная реализация SPI для каскада 74HC595.
*   **Фоновая развертка:** Использование `repeating_timer` (RP2040 SDK) для стабильной частоты обновления.
*   **Глубина яркости:** 8 бит (0..255) на каждый разряд (Per-digit PWM).
*   **Гамма-коррекция:** Встроенная LUT/функция для линеаризации восприятия яркости.
*   **Anti-Ghosting:** Аппаратная защита от паразитной засветки соседних разрядов.

---

## 2. Аппаратная конфигурация

Драйвер ожидает следующую схему подключения сдвиговых регистров (74HC595):
1.  **Порядок данных:** Сначала загружается паттерн сетки (Grid), затем паттерн сегментов (Segments).
2.  **Протокол:**
    *   `Clock` (SH_CP)
    *   `Data` (DS)
    *   `Latch` (ST_CP)

---

## 3. Конфигурация и Типы данных

### `display_ll_config_t`
Структура конфигурации инициализации.

```c
typedef struct {
    uint8_t data_pin;        // GPIO для Data (DS)
    uint8_t clock_pin;       // GPIO для Clock (SH_CP)
    uint8_t latch_pin;       // GPIO для Latch (ST_CP)
    
    uint8_t digit_count;     // Количество разрядов (1..10)
    uint16_t refresh_rate_hz;// Частота обновления всего дисплея (рек. 100-120 Гц)
} display_ll_config_t;
```

### `vfd_segment_map_t`
Тип данных для паттерна сегментов (ранее `vfd_seg_t`). Представляет собой байт, где каждый бит управляет конкретным сегментом.

**Битовая карта (Bit Mapping):**

| Bit | Сегмент | Описание |
| :--- | :--- | :--- |
| **7** | **DP** | Decimal Point (Точка) |
| **6** | **A** | Верхний |
| **5** | **F** | Верхний левый |
| **4** | **E** | Нижний левый |
| **3** | **D** | Нижний |
| **2** | **G** | Средний |
| **1** | **B** | Верхний правый |
| **0** | **C** | Нижний правый |

*   Бит = 1: Сегмент включен.
*   Бит = 0: Сегмент выключен.

TODO: Добавить картинку индикатора. 
---

## 4. Функции управления (API)

### Инициализация

#### `bool display_ll_init(const display_ll_config_t *cfg)`
Инициализирует GPIO, выделяет память под буферы и настраивает внутренние структуры.
*   **cfg:** Указатель на заполненную структуру конфигурации.
*   **Возврат:** `true` при успехе.

#### `void display_ll_deinit(void)`
Останавливает таймеры, освобождает ресурсы и переводит пины в состояние High-Z.

---

### Управление разверткой

#### `bool display_ll_start_refresh(void)`
Запускает прерывания таймера. Дисплей начинает светиться.
*   **Возврат:** `true`, если таймер успешно запущен.

#### `void display_ll_stop_refresh(void)`
Останавливает прерывания и гасит дисплей (отправляет 0x00).

---

# Low-Level Layer v4.0 — API Reference

... (Начало файла без изменений) ...

---

### Рендеринг (Вывод данных)

#### `void display_ll_set_digit_raw(uint8_t idx, vfd_segment_map_t segments)`
Устанавливает паттерн сегментов для конкретного разряда.
*   **idx:** Индекс разряда (0..digit_count-1).
*   **segments:** Карта сегментов (байт).
*   **Обработка ошибок:**
    *   *Debug:* Вызывает `assert` и остановку программы, если `idx` выходит за пределы.
    *   *Release:* Безопасно игнорирует операцию, если `idx` неверен.

#### `void display_ll_set_brightness(uint8_t idx, uint8_t level)`
Устанавливает яркость для конкретного разряда.
*   **idx:** Индекс разряда.
*   **level:** Уровень PWM (0 = выкл, 255 = макс).
*   **Обработка ошибок:** См. `set_digit_raw`.



---

### Утилиты и Гамма

#### `void display_ll_enable_gamma(bool enable)`
Включает или выключает автоматическое применение гаммы внутри драйвера.
*   *Default:* true.

#### `uint8_t display_ll_apply_gamma(uint8_t linear)`
Вспомогательная функция. Преобразует линейное значение яркости (0..255) в скорректированное.

#### `vfd_segment_map_t *display_ll_get_buffer(void)`
Возвращает "сырой" указатель на видеопамять (массив сегментов).

---

## 5. Внутренняя логика работы (Architecture)

Драйвер работает на базе двух событий:

1.  **Slot Timer (Repeating Timer):**
    *   Срабатывает с частотой `RefreshRate * DigitCount`.
    *   Загружает данные для *следующего* разряда в сдвиговый регистр.
    *   Делает `LATCH`.
    *   Если яркость < 255, взводит однократный `Alarm` на выключение.

2.  **Clear Alarm (Hardware Alarm):**
    *   Срабатывает через время $T_{on}$, пропорциональное яркости.
    *   Гасит дисплей (отправляет 0x00), реализуя PWM.

### Anti-Ghosting (Защита от засветки)
В версии 1.0 реализован механизм "Dead Time".
Время горения рассчитывается так:
$$T_{on} = \min(PWM_{calc}, T_{slot} - 10\mu s)$$
Это гарантирует, что аноды погаснут за 10 микросекунд до переключения на следующую сетку.

---

## 6. Пример использования 

Пример использования LL-драйвера без HL-библиотеки:

```c
#include "display_ll.h"

void main() {
    display_ll_config_t cfg = {
        .data_pin = 15,
        .clock_pin = 14,
        .latch_pin = 13,
        .digit_count = 4,
        .refresh_rate_hz = 120
    };

    display_ll_init(&cfg);

    // Пример: вывести "8" (0x7F) на первом разряде
    vfd_segment_map_t digit8 = 0b01111111;
    
    display_ll_set_digit_raw(0, digit8); 
    display_ll_set_brightness(0, 50);

    display_ll_start_refresh();

    while(1) {
        tight_loop_contents();
    }
}
```