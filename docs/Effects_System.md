
---

# VFD Display — Effects System (FX)

**Версия:** 1.0.0
**Статус:** Stable

Документ описывает архитектуру движка эффектов `display_fx.c`, механизмы наложения анимаций и классификацию визуальных режимов.

---

## 1. Концепция FX Engine v4.0

В версии 4.0 движок эффектов был фундаментально переработан для поддержки **многозадачности отображения**.

**Ключевые принципы:**
1.  **Прозрачность (Transparency):** Эффекты могут накладываться *поверх* основного контента (часов), не останавливая его обновление.
2.  **Безопасность состояния (State Safety):** Перед запуском разрушительных (блокирующих) анимаций текущее состояние экрана сохраняется (Snapshot), а после завершения — восстанавливается.
3.  **Изоляция:** FX-движок не работает с GPIO напрямую, он управляет только логическими уровнями яркости и буферами сегментов.

---

## 2. Архитектура и Типы эффектов

Движок разделяет все эффекты на три категории в зависимости от того, как они взаимодействуют с основным контентом.

### 2.1. Intensity Effects (Прозрачные)
Эффекты этой группы модифицируют **только яркость** (глобальную или поразрядную) в Low-Level слое.

*   **Поведение:** Основной цикл (`display_process`) продолжает обновлять время/числа в буфере сегментов. Пользователь видит идущие часы, поверх которых наложена световая анимация.
*   **Примеры:** Pulse, Wave, Scanner.

### 2.2. Structural Effects (Блокирующие)
Эффекты этой группы захватывают управление **сегментами**.

*   **Поведение:**
    1.  При старте: Текущий контент сохраняется в `saved_content_buffer`.
    2.  Во время работы: Обновление контента извне игнорируется. Эффект сам рисует изображение.
    3.  При завершении: `saved_content_buffer` восстанавливается обратно.
*   **Примеры:** Glitch, Morph, Dissolve.

### 2.3. Text Effects (Текстовые)
Специальный подвид блокирующих эффектов для работы со строками.

*   **Поведение:** Используют выделенный буфер `fx_text_buffer[64]`. Рендерят бегущую строку или анимацию появления текста.
*   **Примеры:** Marquee, Slide In.

---

## 3. Список эффектов

### Группа A: Атмосферные (Прозрачные)

| Эффект | Описание | Визуализация |
|---|---|---|
| **Pulse** | Синусоидальное "дыхание" всей панели. | Плавное затухание до 5% и возврат к 100%. |
| **Wave** | Волна яркости. | Световое пятно пробегает слева направо. |
| **Scanner** | Эффект "KITT" / "Cylon". | Яркий "глаз" бегает туда-сюда с затухающим шлейфом. |

| **Fade In/Out** | Глобальное затухание. | Плавный уход в черноту и обратно. |

### Группа B: Анимации перехода (Блокирующие)

| Эффект | Описание | Применение |
|---|---|---|
| **Morph** | Побитовое превращение. | Плавная смена одного слова на другое (COOL -> HEAT). |
| **Dissolve** | Рассыпание. | Пиксели гаснут в случайном порядке ("песок"). |
| **Glitch** | Цифровой сбой. | Хаотичная подмена сегментов (эффект поломки/хакера). |


### Группа C: Текстовые

| Эффект | Описание | Опции |
|---|---|---|
| **Marquee** | Бегущая строка. | Скроллинг длинного текста справа налево. |
| **Slide In** | Выезд текста. | Текст выезжает справа и фиксируется. |

---

## 4. Внутреннее устройство (Implementation Details)

### 4.1. State Machine
FX-движок управляется через структуру `display_state_t` (в `display_core.c`):

```c
typedef struct {
    volatile bool      fx_active;      // Флаг работы
    volatile fx_type_t fx_type;        // Тип текущего эффекта
    absolute_time_t    fx_start_time;  // Время старта
    uint32_t           fx_duration_ms; // Общая длительность
    
    // Буферы для восстановления
    vfd_seg_t saved_content_buffer[VFD_MAX_DIGITS];
    uint8_t   saved_brightness[VFD_MAX_DIGITS];
    
    // Текстовый буфер
    char      fx_text_buffer[FX_TEXT_MAX_LEN];
} display_state_t;
```

### 4.2. Жизненный цикл

1.  **Start:** Вызов API (напр. `display_fx_wave()`) устанавливает тип, длительность и делает Snapshot (если нужно).
2.  **Tick:** `display_process()` вызывает `display_fx_tick()`.
    *   Вычисляется `elapsed_ms`.
    *   Вызывается конкретная реализация (напр. `fx_apply_wave`).
    *   Результат пушится в LL (яркость или сегменты).
3.  **Finish:** По истечении времени вызывается `fx_finish_internal()`.
    *   Восстанавливается яркость.
    *   Если эффект был блокирующим — восстанавливаются сегменты.
    *   Вызывается callback `on_effect_finished` (если задан).

---

## 5. API Reference

### Запуск эффектов

Все функции возвращают `true`, если эффект успешно запущен.

```c
// Прозрачные
bool display_fx_pulse(uint32_t duration_ms);
bool display_fx_wave(uint32_t duration_ms);
bool display_fx_scanner(uint32_t duration_ms);
bool display_fx_fade_in(uint32_t duration_ms);
bool display_fx_fade_out(uint32_t duration_ms);

// Блокирующие
bool display_fx_glitch(uint32_t duration_ms);
bool display_fx_dissolve(uint32_t duration_ms);


// С целевым значением (target)
bool display_fx_morph(uint32_t duration_ms, const vfd_seg_t *target, uint32_t steps);
bool display_fx_decode(uint32_t duration_ms, const vfd_seg_t *target);

// Текстовые
bool display_fx_marquee(const char *text, uint32_t speed_ms);
bool display_fx_slide_in(const char *text, uint32_t speed_ms);
```

### Управление

```c
void display_fx_stop(void);         // Принудительная остановка
bool display_is_effect_running(void); // Статус
```

---

## 6. Принципы разработки

1.  **Non-Blocking Logic:** Эффекты не используют `sleep_ms`. Вся анимация рассчитывается на основе `get_absolute_time()`.
2.  **Gamma Correctness:** Все эффекты яркости проходят через гамма-коррекцию (x^2) в LL-слое для естественного восприятия.
3.  **Zero-Allocation:** FX-движок не использует кучу (`malloc`). Все буферы статически выделены.
